package org.checkerframework.specimin.unsolved;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.checkerframework.checker.signature.qual.ClassGetSimpleName;
import org.checkerframework.specimin.JavaParserUtil;

/**
 * Given a set of fully qualified type name, hold all possible type definitions. For example, if
 * given a set containing FQNs like org.example.Apple.Banana, generate alternates where it can be
 * any of the following:
 *
 * <ul>
 *   <li>class Banana in package org.example.Apple
 *   <li>inner class Banana in class Apple in package org.example
 *   <li>inner class Banana in inner class Apple in class example in package org
 * </ul>
 */
public class UnsolvedClassOrInterfaceAlternates
    extends UnsolvedSymbolAlternates<UnsolvedClassOrInterface>
    implements UnsolvedClassOrInterfaceCommon {

  private Set<String> fullyQualifiedNames = new LinkedHashSet<>();

  private UnsolvedClassOrInterfaceAlternates(
      List<UnsolvedClassOrInterfaceAlternates> potentialDeclaringTypes) {
    super(potentialDeclaringTypes);
  }

  /**
   * Creates a new List of UnsolvedClassOrInterfaceAlternates, given a set of FQNs. The first
   * element of the returned list is always the type generated by the FQNs; subsequent classes are
   * potential outer classes of the type. The simple class name is the same among all alternates.
   *
   * @param fqns The set of fqns
   * @param generatedSymbolsMap The map of generated symbols from UnsolvedSymbolGenerator. This is
   *     to ensure potential outer classes are not duplicated
   * @return A list of generated types; the first is the type of the fqns, the next few are
   *     potential outer classes
   */
  public static List<UnsolvedClassOrInterfaceAlternates> create(
      Set<String> fqns, Map<String, UnsolvedSymbolAlternates<?>> generatedSymbolsMap) {
    if (fqns.isEmpty()) {
      throw new RuntimeException("The set of fully-qualified names cannot be empty.");
    }

    List<UnsolvedClassOrInterfaceAlternates> allGenerated = new ArrayList<>();
    List<UnsolvedClassOrInterfaceAlternates> potentialDeclaringTypes = new ArrayList<>();
    List<UnsolvedClassOrInterface> alternates = new ArrayList<>();

    for (String fqn : fqns) {
      // In org.example.Class.Class2, we go from Class2 --> Class.Class2 --> example.Class.Class2
      String packageName = fqn.substring(0, fqn.lastIndexOf('.'));
      String className = fqn.substring(packageName.length() + 1);

      UnsolvedClassOrInterface type = new UnsolvedClassOrInterface(className, packageName);
      alternates.add(type);

      if (packageName.contains(".") && !JavaParserUtil.isProbablyAPackage(packageName)) {
        potentialDeclaringTypes.add(
            createPotentialContainingClass(packageName, allGenerated, generatedSymbolsMap));
      }
    }

    UnsolvedClassOrInterfaceAlternates current =
        new UnsolvedClassOrInterfaceAlternates(potentialDeclaringTypes);

    // The first element of the list should always be the type generated by a call
    // to this method, for predictable access to consumers of this method.
    allGenerated.add(0, current);

    for (UnsolvedClassOrInterface alt : alternates) {
      current.addAlternate(alt);
    }

    return allGenerated;
  }

  /**
   * Helper method to create parent classes, based on a FQN. For example, if org.example.Class is
   * passed in, Class in org.example is created, while class example in package org is also created.
   *
   * @param fqn The fully-qualified name
   * @param allGenerated A list of all generated symbols (such as org.example.Class and org.example)
   * @param generatedSymbolsMap The map of fully-qualified names to generated symbols from
   *     UnsolvedSymbolGenerator. This is to ensure potential outer classes are not duplicated
   * @return The most immediate unsolved type generated; i.e., the one that has an FQN equal to the
   *     argument corresponding with {@code fqn}.
   */
  private static UnsolvedClassOrInterfaceAlternates createPotentialContainingClass(
      String fqn,
      List<UnsolvedClassOrInterfaceAlternates> allGenerated,
      Map<String, UnsolvedSymbolAlternates<?>> generatedSymbolsMap) {
    String qualifier = fqn.substring(0, fqn.lastIndexOf('.'));
    String className = fqn.substring(qualifier.length() + 1);

    UnsolvedClassOrInterfaceAlternates generated;

    if (generatedSymbolsMap.containsKey(qualifier)) {
      return (UnsolvedClassOrInterfaceAlternates) generatedSymbolsMap.get(qualifier);
    }

    if (qualifier.contains(".") && !JavaParserUtil.isProbablyAPackage(qualifier)) {
      generated =
          new UnsolvedClassOrInterfaceAlternates(
              List.of(
                  createPotentialContainingClass(qualifier, allGenerated, generatedSymbolsMap)));
    } else {
      generated = new UnsolvedClassOrInterfaceAlternates(List.of());
    }

    generated.addAlternate(new UnsolvedClassOrInterface(className, qualifier));

    allGenerated.add(generated);
    return generated;
  }

  /**
   * Given an updated set of potential fully-qualified names, this method finds the intersection of
   * the two sets and updates the existing set.
   *
   * @param updated The additional set
   */
  public void updateFullyQualifiedNames(Set<String> updated) {
    // Update in-place; intersection = removing all elements in the original set
    // that isn't found in the updated set
    fullyQualifiedNames.removeIf(name -> !updated.contains(name));
    getAlternates()
        .removeIf(alternate -> !fullyQualifiedNames.contains(alternate.getFullyQualifiedName()));

    String simpleName = JavaParserUtil.getSimpleNameFromQualifiedName(updated.iterator().next());
    getAlternateDeclaringTypes()
        .removeIf(
            alternateDeclType ->
                alternateDeclType.getFullyQualifiedNames().stream()
                    .anyMatch(name -> !fullyQualifiedNames.contains(name + "." + simpleName)));
  }

  @Override
  public Set<String> getFullyQualifiedNames() {
    return fullyQualifiedNames;
  }

  @Override
  protected void addAlternate(UnsolvedClassOrInterface alternate) {
    super.addAlternate(alternate);
    this.fullyQualifiedNames.add(alternate.getFullyQualifiedName());
  }

  /**
   * Extends this class based on a MemberType.
   *
   * @param extendsType The type to extend
   */
  @Override
  public void extend(MemberType extendsType) {
    applyToAllAlternates(UnsolvedClassOrInterface::extend, extendsType);
  }

  /**
   * Returns true if this class has an extends clause.
   *
   * @return True if this class has an extends clause.
   */
  @Override
  public boolean hasExtends() {
    return doAllAlternatesReturnTrueFor(UnsolvedClassOrInterface::hasExtends);
  }

  /**
   * Returns true if this class extends the given extendsType.
   *
   * @param extendsType The type to extend
   * @return True if this type extends the given extendsType.
   */
  @Override
  public boolean doesExtend(MemberType extendsType) {
    return doAllAlternatesReturnTrueFor(UnsolvedClassOrInterface::doesExtend, extendsType);
  }

  @Override
  public void addAnnotation(String annotation) {
    applyToAllAlternates(UnsolvedClassOrInterface::addAnnotation, annotation);
  }

  /**
   * Implements this class based on a MemberType.
   *
   * @param interfaceName The type to implement
   */
  @Override
  public void implement(String interfaceName) {
    // TODO: make this MemberType also
    applyToAllAlternates(UnsolvedClassOrInterface::implement, interfaceName);
  }

  /**
   * Returns true if this class implements the given interface.
   *
   * @param interfaceName The type to implement
   * @return True if this type implements the given interface.
   */
  @Override
  public boolean doesImplement(String interfaceName) {
    return doAllAlternatesReturnTrueFor(UnsolvedClassOrInterface::doesImplement, interfaceName);
  }

  /**
   * Sets the number of type variables.
   *
   * @param number The number of type variables.
   */
  @Override
  public void setNumberOfTypeVariables(int number) {
    applyToAllAlternates(UnsolvedClassOrInterface::setNumberOfTypeVariables, number);
  }

  /**
   * Gets the type variables as a String without brackets (i.e., <T1, T2> --> T1, T2)
   *
   * @return The type variables without brackets
   */
  @Override
  public String getTypeVariablesAsStringWithoutBrackets() {
    return getAlternates().get(0).getTypeVariablesAsStringWithoutBrackets();
  }

  @Override
  public int getNumberOfTypeVariables() {
    return getAlternates().get(0).getNumberOfTypeVariables();
  }

  @Override
  public @ClassGetSimpleName String getClassName() {
    return getAlternates().get(0).getClassName();
  }

  @Override
  public String getTypeVariablesAsString() {
    return getAlternates().get(0).getTypeVariablesAsString();
  }

  @Override
  public UnsolvedClassOrInterfaceType getType() {
    return getAlternates().get(0).getType();
  }

  @Override
  public void setType(UnsolvedClassOrInterfaceType type) {
    boolean wasOriginallyAnAnnotation = getType() == UnsolvedClassOrInterfaceType.ANNOTATION;

    applyToAllAlternates(UnsolvedClassOrInterface::setType, type);

    if (type != UnsolvedClassOrInterfaceType.ANNOTATION) {
      return;
    }

    if (!wasOriginallyAnAnnotation) {
      for (UnsolvedClassOrInterface alternate : List.copyOf(getAlternates())) {
        UnsolvedClassOrInterface typeUseAnnos = alternate.copy();
        UnsolvedClassOrInterface typeAnnos = alternate.copy();
        alternate.addAnnotation(
            "@java.lang.annotation.Target({ java.lang.annotation.ElementType.TYPE_USE,"
                + " java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD,"
                + " java.lang.annotation.ElementType.METHOD,"
                + " java.lang.annotation.ElementType.PARAMETER,"
                + " java.lang.annotation.ElementType.CONSTRUCTOR,"
                + " java.lang.annotation.ElementType.LOCAL_VARIABLE,"
                + " java.lang.annotation.ElementType.ANNOTATION_TYPE,"
                + " java.lang.annotation.ElementType.PACKAGE,"
                + " java.lang.annotation.ElementType.TYPE_PARAMETER})");
        typeUseAnnos.addAnnotation(
            "@java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE)");
        typeAnnos.addAnnotation(
            "@java.lang.annotation.Target({ java.lang.annotation.ElementType.TYPE,"
                + " java.lang.annotation.ElementType.FIELD,"
                + " java.lang.annotation.ElementType.METHOD,"
                + " java.lang.annotation.ElementType.PARAMETER,"
                + " java.lang.annotation.ElementType.CONSTRUCTOR,"
                + " java.lang.annotation.ElementType.LOCAL_VARIABLE,"
                + " java.lang.annotation.ElementType.ANNOTATION_TYPE,"
                + " java.lang.annotation.ElementType.PACKAGE,"
                + " java.lang.annotation.ElementType.TYPE_PARAMETER})");

        addAlternate(typeUseAnnos);
        addAlternate(typeAnnos);
      }
    }
  }
}
