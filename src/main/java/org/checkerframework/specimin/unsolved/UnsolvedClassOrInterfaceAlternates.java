package org.checkerframework.specimin.unsolved;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

/**
 * Given a set of fully qualified type name, hold all possible type definitions. For example, if
 * given a set containing FQNs like org.example.Apple.Banana, generate alternates where it can be
 * any of the following:
 *
 * <ul>
 *   <li>class Banana in package org.example.Apple
 *   <li>inner class Banana in class Apple in package org.example
 *   <li>inner class Banana in inner class Apple in class example in package org
 * </ul>
 */
public class UnsolvedClassOrInterfaceAlternates
    extends UnsolvedSymbolAlternates<UnsolvedClassOrInterface> {

  private Set<String> fullyQualifiedNames = new LinkedHashSet<>();

  private UnsolvedClassOrInterfaceAlternates(
      List<UnsolvedClassOrInterfaceAlternates> potentialDeclaringTypes) {
    super(potentialDeclaringTypes);
  }

  /**
   * Creates a new List of UnsolvedClassOrInterfaceAlternates, given a set of FQNs. The first
   * element of the returned list is always the type generated by the FQNs; subsequent classes are
   * potential outer classes of the type. The simple class name is the same among all alternates.
   *
   * @param fqns The set of fqns
   * @return A list of generated types; the first is the type of the fqns, the next few are
   *     potential outer classes
   */
  public static List<UnsolvedClassOrInterfaceAlternates> create(Set<String> fqns) {
    List<UnsolvedClassOrInterfaceAlternates> allGenerated = new ArrayList<>();
    List<UnsolvedClassOrInterfaceAlternates> potentialDeclaringTypes = new ArrayList<>();
    List<UnsolvedClassOrInterface> alternates = new ArrayList<>();

    for (String fqn : fqns) {
      // In org.example.Class.Class2, we go from Class2 --> Class.Class2 --> example.Class.Class2
      String packageName = fqn.substring(0, fqn.lastIndexOf('.'));
      String className = fqn.substring(packageName.length() + 1);

      UnsolvedClassOrInterface type = new UnsolvedClassOrInterface(className, packageName);
      alternates.add(type);

      if (packageName.contains(".")) {
        potentialDeclaringTypes.add(createPotentialContainingClass(packageName, allGenerated));
      }
    }

    UnsolvedClassOrInterfaceAlternates current =
        new UnsolvedClassOrInterfaceAlternates(potentialDeclaringTypes);

    allGenerated.add(0, current);

    for (UnsolvedClassOrInterface alt : alternates) {
      current.addAlternate(alt);
    }

    return allGenerated;
  }

  /**
   * Helper method to create parent classes, based on a FQN. For example, if org.example.Class is
   * passed in, Class in org.example is created, while class example in package org is also created.
   *
   * @param fqn The fully-qualified name
   * @param allGenerated A list of all generated symbols (such as org.example.Class and org.example)
   * @return The most immediate unsolved type generated; i.e., the one that has an FQN equal to the
   *     argument corresponding with {@code fqn}.
   */
  private static UnsolvedClassOrInterfaceAlternates createPotentialContainingClass(
      String fqn, List<UnsolvedClassOrInterfaceAlternates> allGenerated) {
    String packageName = fqn.substring(0, fqn.lastIndexOf('.'));
    String className = fqn.substring(packageName.length() + 1);

    UnsolvedClassOrInterfaceAlternates generated;

    if (packageName.contains(".")) {
      generated =
          new UnsolvedClassOrInterfaceAlternates(
              List.of(createPotentialContainingClass(packageName, allGenerated)));
    } else {
      generated = new UnsolvedClassOrInterfaceAlternates(List.of());
    }

    generated.addAlternate(new UnsolvedClassOrInterface(className, packageName));

    allGenerated.add(generated);
    return generated;
  }

  /**
   * Given an updated set of potential fully-qualified names, this method finds the intersection of
   * the two sets and updates the existing set.
   *
   * @param updated The additional set
   */
  public void updateFullyQualifiedNames(Set<String> updated) {
    // Update in-place; intersection = removing all elements in the original set
    // that isn't found in the updated set
    getAlternates()
        .removeIf(alternate -> !fullyQualifiedNames.contains(alternate.getFullyQualifiedName()));
    fullyQualifiedNames.removeIf(name -> !updated.contains(name));
  }

  @Override
  public Set<String> getFullyQualifiedNames() {
    return fullyQualifiedNames;
  }

  @Override
  protected void addAlternate(UnsolvedClassOrInterface alternate) {
    super.addAlternate(alternate);
    this.fullyQualifiedNames.add(alternate.getFullyQualifiedName());
  }

  /**
   * Returns true if this represents an interface.
   *
   * @return True if this represents an interface.
   */
  public boolean isAnInterface() {
    // All alternates are either all interfaces or all classes
    return getAlternates().get(0).isAnInterface();
  }

  /** Sets this type to an interface. */
  public void setIsAnInterfaceToTrue() {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      alternate.setIsAnInterfaceToTrue();
    }
  }

  /** Sets this type to an annotation and generates additional alternates. */
  public void setIsAnAnnotationToTrue() {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      boolean orig = alternate.isAnAnnotation();
      alternate.setIsAnAnnotationToTrue();

      if (!orig) {
        UnsolvedClassOrInterface typeUse = alternate.copy();
        UnsolvedClassOrInterface type = alternate.copy();
        alternate.addAnnotation(
            "@java.lang.annotation.Target({ java.lang.annotation.ElementType.TYPE_USE,"
                + " java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD,"
                + " java.lang.annotation.ElementType.METHOD,"
                + " java.lang.annotation.ElementType.PARAMETER,"
                + " java.lang.annotation.ElementType.CONSTRUCTOR,"
                + " java.lang.annotation.ElementType.LOCAL_VARIABLE,"
                + " java.lang.annotation.ElementType.ANNOTATION_TYPE,"
                + " java.lang.annotation.ElementType.PACKAGE,"
                + " java.lang.annotation.ElementType.TYPE_PARAMETER})");
        typeUse.addAnnotation(
            "@java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE)");
        type.addAnnotation(
            "@java.lang.annotation.Target({ java.lang.annotation.ElementType.TYPE,"
                + " java.lang.annotation.ElementType.FIELD,"
                + " java.lang.annotation.ElementType.METHOD,"
                + " java.lang.annotation.ElementType.PARAMETER,"
                + " java.lang.annotation.ElementType.CONSTRUCTOR,"
                + " java.lang.annotation.ElementType.LOCAL_VARIABLE,"
                + " java.lang.annotation.ElementType.ANNOTATION_TYPE,"
                + " java.lang.annotation.ElementType.PACKAGE,"
                + " java.lang.annotation.ElementType.TYPE_PARAMETER})");

        addAlternate(typeUse);
        addAlternate(type);
      }
    }
  }

  /**
   * Extends this class based on a MemberType.
   *
   * @param extendsType The type to extend
   */
  public void extend(MemberType extendsType) {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      alternate.extend(extendsType);
    }
  }

  /**
   * Returns true if this class has an extends clause.
   *
   * @return True if this class has an extends clause.
   */
  public boolean hasExtends() {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      if (alternate.hasExtends()) return true;
    }
    return false;
  }

  /**
   * Returns true if this class extends the given extendsType.
   *
   * @param extendsType The type to extend
   * @return True if this type extends the given extendsType.
   */
  public boolean doesExtend(MemberType extendsType) {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      if (alternate.doesExtend(extendsType)) return true;
    }
    return false;
  }

  /**
   * Implements this class based on a MemberType.
   *
   * @param interfaceName The type to implement
   */
  public void implement(String interfaceName) {
    // TODO: make this MemberType also
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      alternate.implement(interfaceName);
    }
  }

  /**
   * Returns true if this class implements the given interface.
   *
   * @param interfaceName The type to implement
   * @return True if this type implements the given interface.
   */
  public boolean doesImplement(String interfaceName) {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      if (alternate.doesImplement(interfaceName)) return true;
    }
    return false;
  }

  /**
   * Sets the number of type variables.
   *
   * @param number The number of type variables.
   */
  public void setNumberOfTypeVariables(int number) {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      alternate.setNumberOfTypeVariables(number);
    }
  }

  /**
   * Gets the type variables as a String without brackets (i.e., <T1, T2> --> T1, T2)
   *
   * @return The type variables without brackets
   */
  public String getTypeVariablesAsStringWithoutBrackets() {
    return getAlternates().get(0).getTypeVariablesAsStringWithoutBrackets();
  }
}
