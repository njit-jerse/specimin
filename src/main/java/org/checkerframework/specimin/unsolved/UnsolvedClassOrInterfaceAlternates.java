package org.checkerframework.specimin.unsolved;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Given a set of fully qualified type name, hold all possible type definitions. For example, if
 * given a set containing FQNs like org.example.Apple.Banana, generate alternates where it can be
 * any of the following:
 *
 * <ul>
 *   <li>class Banana in package org.example.Apple
 *   <li>inner class Banana in class Apple in package org.example
 *   <li>inner class Banana in inner class Apple in class example in package org
 * </ul>
 */
public class UnsolvedClassOrInterfaceAlternates
    extends UnsolvedSymbolAlternates<UnsolvedClassOrInterface> {

  private Set<String> fullyQualifiedNames = new HashSet<>();

  private UnsolvedClassOrInterfaceAlternates(
      List<UnsolvedClassOrInterfaceAlternates> potentialDeclaringTypes) {
    super(potentialDeclaringTypes);
  }

  /**
   * Creates a new List of UnsolvedClassOrInterfaceAlternates, given a set of FQNs. The first
   * element of the returned list is always the type generated by the FQNs; subsequent classes are
   * potential outer classes of the type.
   *
   * @param fqns The set of fqns
   * @return A list of generated types; the first is the type of the fqns, the next few are
   *     potential outer classes
   */
  public static List<UnsolvedClassOrInterfaceAlternates> create(Set<String> fqns) {
    List<UnsolvedClassOrInterfaceAlternates> allGenerated = new ArrayList<>();
    List<UnsolvedClassOrInterfaceAlternates> potentialDeclaringTypes = new ArrayList<>();
    List<UnsolvedClassOrInterface> alternates = new ArrayList<>();

    System.out.println(fqns);
    for (String fqn : fqns) {
      // In org.example.Class.Class2, we go from Class2 --> Class.Class2 --> example.Class.Class2
      String packageName = fqn.substring(0, fqn.lastIndexOf('.'));
      String className = fqn.substring(packageName.length() + 1);

      UnsolvedClassOrInterface type = new UnsolvedClassOrInterface(className, packageName);
      alternates.add(type);

      if (packageName.contains(".")) {
        potentialDeclaringTypes.add(createPotentialContainingClass(packageName, allGenerated));
      }
    }

    UnsolvedClassOrInterfaceAlternates current =
        new UnsolvedClassOrInterfaceAlternates(potentialDeclaringTypes);

    allGenerated.add(0, current);

    for (UnsolvedClassOrInterface alt : alternates) {
      current.addAlternate(alt);
    }

    return allGenerated;
  }

  private static UnsolvedClassOrInterfaceAlternates createPotentialContainingClass(
      String fqn, List<UnsolvedClassOrInterfaceAlternates> allGenerated) {
    String packageName = fqn.substring(0, fqn.lastIndexOf('.'));
    String className = fqn.substring(packageName.length() + 1);

    UnsolvedClassOrInterfaceAlternates generated;

    if (packageName.contains(".")) {
      generated =
          new UnsolvedClassOrInterfaceAlternates(
              List.of(createPotentialContainingClass(packageName, allGenerated)));
    } else {
      generated = new UnsolvedClassOrInterfaceAlternates(List.of());
    }

    generated.addAlternate(new UnsolvedClassOrInterface(className, packageName));

    allGenerated.add(generated);
    return generated;
  }

  /**
   * Given an updated set of potential fully-qualified names, this method finds the intersection of
   * the two sets and updates the existing set.
   *
   * @param updated The additional set
   */
  public void updateFullyQualifiedNames(Set<String> updated) {
    // Update in-place; intersection = removing all elements in the original set
    // that isn't found in the updated set
    getAlternates()
        .removeIf(alternate -> !fullyQualifiedNames.contains(alternate.getFullyQualifiedName()));
    fullyQualifiedNames.removeIf(name -> !updated.contains(name));
  }

  @Override
  public Set<String> getFullyQualifiedNames() {
    return fullyQualifiedNames;
  }

  @Override
  protected void addAlternate(UnsolvedClassOrInterface alternate) {
    super.addAlternate(alternate);
    this.fullyQualifiedNames.add(alternate.getFullyQualifiedName());
  }

  public boolean isAnInterface() {
    // All alternates are either classes or interfaces
    return getAlternates().get(0).isAnInterface();
  }

  public void setIsAnInterfaceToTrue() {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      alternate.setIsAnInterfaceToTrue();
    }
  }

  public void setIsAnAnnotationToTrue() {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      boolean orig = alternate.isAnAnnotation();
      alternate.setIsAnAnnotationToTrue();

      if (!orig) {
        UnsolvedClassOrInterface typeUse = alternate.copy();
        UnsolvedClassOrInterface type = alternate.copy();
        alternate.addAnnotation(
            "@java.lang.annotation.Target({ java.lang.annotation.ElementType.TYPE_USE,"
                + " java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.FIELD,"
                + " java.lang.annotation.ElementType.METHOD,"
                + " java.lang.annotation.ElementType.PARAMETER,"
                + " java.lang.annotation.ElementType.CONSTRUCTOR,"
                + " java.lang.annotation.ElementType.LOCAL_VARIABLE,"
                + " java.lang.annotation.ElementType.ANNOTATION_TYPE,"
                + " java.lang.annotation.ElementType.PACKAGE,"
                + " java.lang.annotation.ElementType.TYPE_PARAMETER})");
        typeUse.addAnnotation(
            "@java.lang.annotation.Target(java.lang.annotation.ElementType.TYPE_USE)");
        type.addAnnotation(
            "@java.lang.annotation.Target({ java.lang.annotation.ElementType.TYPE,"
                + " java.lang.annotation.ElementType.FIELD,"
                + " java.lang.annotation.ElementType.METHOD,"
                + " java.lang.annotation.ElementType.PARAMETER,"
                + " java.lang.annotation.ElementType.CONSTRUCTOR,"
                + " java.lang.annotation.ElementType.LOCAL_VARIABLE,"
                + " java.lang.annotation.ElementType.ANNOTATION_TYPE,"
                + " java.lang.annotation.ElementType.PACKAGE,"
                + " java.lang.annotation.ElementType.TYPE_PARAMETER})");

        addAlternate(typeUse);
        addAlternate(type);
      }
    }
  }

  public void extend(MemberType extendsType) {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      alternate.extend(extendsType);
    }
  }

  public boolean doesExtend(MemberType extendsType) {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      if (alternate.doesExtend(extendsType)) return true;
    }
    return false;
  }

  public void implement(String interfaceName) {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      alternate.implement(interfaceName);
    }
  }

  public boolean doesImplement(String interfaceName) {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      if (alternate.doesImplement(interfaceName)) return true;
    }
    return false;
  }

  public void setNumberOfTypeVariables(int number) {
    for (UnsolvedClassOrInterface alternate : getAlternates()) {
      alternate.setNumberOfTypeVariables(number);
    }
  }

  public String getTypeVariablesAsStringWithoutBrackets() {
    return getAlternates().get(0).getTypeVariablesAsStringWithoutBrackets();
  }
}
