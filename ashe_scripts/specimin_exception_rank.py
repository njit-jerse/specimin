"""
Script for analyzing log files generated by ASHE in dryrun mode.
https://github.com/jonathan-m-phillips/ASHE_Automated-Software-Hardening-for-Entrypoints

Created by: Jonathan Phillips, https://github.com/jonathan-m-phillips
Date: April 13, 2024

Description:
This script reads a log file and ranks the exceptions by how frequently they occur. If the exceptions
occur more often, they are ranked higher. These exception rankings come from running the
Ashe.RepositoryAutomationEngine in dryrun mode.

Output:
Rankings written to a txt file in the same directory as the provided log file.

Usage:
python3 specimin_exception_rank.py <path_to_log_file.log>
"""

import sys
import os
import re
from collections import defaultdict


def analyze_log(file_path: str):
    directory = os.path.dirname(file_path)
    output_file_path = os.path.join(directory, 'specimin_exception_rank.txt')

    with open(file_path, 'r') as file:
        content = file.readlines()

    exceptions = __extract_exceptions(content)
    ranked_exceptions = __rank_exceptions(exceptions)

    __write_ranked_exceptions(ranked_exceptions, output_file_path)
    print("Write successful")


def __extract_exceptions(log_lines):
    """
    Extract exceptions from the log lines. An exception is defined as a line that starts with "Exception in thread"
    Args:
        log_lines: A list of log lines

    Returns: A list of tuples (name, message, example_line)
    """
    # Enhanced to capture an example line following the exception message
    exception_pattern = re.compile(r'^Exception in thread ".*?" (\w+.*?):(.*?)(?=\n\S|\Z)', re.DOTALL)
    context_pattern = re.compile(r'^\s+at (.+)$', re.MULTILINE)
    exceptions = []
    for i, line in enumerate(log_lines):
        match = exception_pattern.search(line)
        if match:
            exception_name, message = match.groups()
            # find the next line that starts with whitespace followed by "at" to capture the context
            context_match = context_pattern.search(log_lines[i + 1] if i + 1 < len(log_lines) else "")
            example_line = context_match.group(1).strip() if context_match else "No code context available"
            exceptions.append([exception_name.strip(), message.strip(), example_line])
    return exceptions


def __rank_exceptions(exceptions):
    """
    Rank the exceptions by how frequently they occur. If the exceptions occur more often, they are ranked higher.
    Args:
        exceptions: A list of tuples (name, message, example_line)

    Returns: A sorted list of tuples (count, examples, name, message)
    """
    grouped_exceptions = defaultdict(list)
    for name, message, example in exceptions:
        simplified_message = simplify_message(message)
        grouped_exceptions[(name, simplified_message)].append(example)

    # convert grouped data into a sorted list of tuples (count, examples, name, message)
    sorted_exceptions = sorted(((len(v), v, k[0], k[1]) for k, v in grouped_exceptions.items()), reverse=True,
                               key=lambda x: x[0])
    return sorted_exceptions


def simplify_message(message):
    """
    Simplify the exception message by removing certain patterns that are not helpful for distinguishing exceptions.
    Args:
        message: The exception message for Specimin developers to analyze

    Returns: A simplified version of the message
    """
    message = re.sub(r'\bat [\w\.$<>]+\(.*?\)', '', message)
    message = re.sub(r'\bLine \d+\b', '', message)
    message = re.sub(r'\bmemory address 0x[\da-f]+\b', '', message, flags=re.I)
    return message.strip()


def __write_ranked_exceptions(ranked_exceptions, output_file_path):
    current_rank = 1
    last_count = None
    rank_increment = 0  # keeps track of how many ranks we should jump after ties

    with open(output_file_path, 'w') as output_file:
        for count, examples, name, message in ranked_exceptions:
            if last_count != count:
                current_rank += rank_increment
                rank_increment = 1  # reset for next potential tie group
            else:
                rank_increment += 1  # increment to account for a tie when next different count comes

            last_count = count
            output_line = f"""
Rank: {current_rank},
Count: {count},
Exception: {name},
Message: {message},
Example: {examples[0]}

"""
            output_file.write(output_line)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python3 specimin_exception_rank.py <path_to_log_file.log>")
        sys.exit(1)
    analyze_log(sys.argv[1])
